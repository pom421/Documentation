### Swift (Romain Asnar)

La résolution des types se fait à la compilation (et augmente le temps de compilation par rapport à Objective C)

Gestion des librairies : Pod ou Carthage (l'enfer à gérer à la main). Fichier podfile (~= package.json)

- AppDelegate.swift : le main de l'app
- ViewController.swift : le premier contrôleur
- storyboard : la partie visuelle
- Assets.xcassets : les images, etc..
- LaunchScreen.storyboard : storyboard pour le 1er écran (branding, afficher très rapidement un écran à l'utilisateur)
- info.plist : fichier de configuration
- Test.xcdatamodeld : "PhpMyAdmin" like pour Core Data 

- fichier "projet" (en cliquant directement dans le navigateur XCode sur le projet)
  - Deployment target : version minimum sur lequel on veut que ça tourne. On peut utiliser des fonctionnalités de 10 et mettre
  en Deployment target 7. Il faudra dans le code ajouter des conditions pour ne pas lancer des fonctionnalités si l'OS du
  périphérique ne les permettent pas.

AppDelegate.swift

- cycle de vie de l'application : quand l'application rentre en background, etc..

États : active, background, foreground ("zombie“) qui nécessite de redémarrer l'app, terminée

Sandboxing : les données de chaque app sont compartimentées. On peut faire communiquer des app entre elles par des app groups.

Les ViewController en iOS font du travail de contrôleur mais aussi une grosse partie de la vue.

MVC => problème les ViewController deviennent massifs

MVC => MVVM : le contrôleur contient un Model-View qui se limite au formatage des données du model. Cela permet également de
factoriser ce formatage entre plusieurs contrôleurs.

Viper : Nouvelle architecture pour iOS

Playground avec MVVM :
https://gist.github.com/romsi/9dee6214b06db33ac02fde0464ba0c5d

Ajout de localisation

clic sur le projet
en haut à gauche, clic sur la liste de choix et se positionner sur le nom du projet
Dans localizations, ajouter fr (dans Main.storyboard)

Pour externaliser même en anglais, sur le storyboard, à droite clic sur le 1er onglet et cliquer sur Localization english avec localizable strings.
tab

TableView & CollectionView : le CollectionView n'oblige pas à prendre toute la largeur du périphérique

Content hugging priority/Content compression resistance priority : permet de savoir qui gagne en priorité sur le contenu textuel
(par exemple 3 boutons qui s'affichent horizontalement)


##Storyboard

Ajout d'un Navigatio Controller : 
- on crée un début de navigation, i.e. une suite d'écran qui vont naviguer les uns après les autres et la possibilité de revenir. 
Les classes Swift qu'on va coder vont correspondre aux écrans, pas au Navigation Controller lui même qui est géré par le système.
La flêche (entry point) pourrait très bien être placé directement sur le premier écran et pas sur le Navigation Controller mais 
on perdrait alors la navigation.

Il faut ajouter un segue de type "root view controller" entre le Navigation controller et le Table view controller" (clic sur le bouton 
jaune du controller dans Interface builder puis à droite, dernier onglet "flêche" pour voir les segues)

Un switch permet de switch sur le type d'une instance

```swift
switch cell {
case let postCell as PostTableViewCell: 
  postCell.nameLabel.text = "Test 1"
```

## Accessibilité et UX 

Ne pas faire de menu hamburger. La Tab bar est à préférer. De plus au niveau développeur, c'est beaucoup plus simple.
zone de clic minimum : 44x44 px
Global tint pour colorer d'une même façon tous les boutons
Adapter les contraintes, hugging et compression pour prévoir un item qui puisse être diminué (par exemple une image). Mais
ce n'est pas aux développeurs de dire être minimisé mais à la MOA (ou designers).

Interface

- Tab bar : menu du bas avec les onglets. Avantage : on sait toujours où l'on est (icone sélectionné)
- Navigation bar : menu en haut, lié à un Navigation Controller particulier
